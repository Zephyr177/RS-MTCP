# MTCP 架构设计文档

## 概述

MTCP (Multi-TCP) 是一个用户态的 TCP 连接聚合系统，通过将多个物理 TCP 连接聚合成单个逻辑连接来提升传输速度和可靠性。

## 核心组件

### 1. 协议层 (protocol.rs)

定义了 MTCP 协议的消息格式：

```
消息结构:
+--------+------------+--------+----------+
| 长度   | 消息类型   | 流ID   | 数据     |
| 4字节  | 1字节      | 4字节  | 变长     |
+--------+------------+--------+----------+
```

**消息类型**:
- `0x01` - Data: 携带数据的消息
- `0x02` - NewStream: 创建新流
- `0x03` - CloseStream: 关闭流
- `0x04` - Heartbeat: 心跳保活

### 2. 连接池 (connection_pool.rs)

管理多个到服务端的 TCP 连接：

**功能**:
- 预建立多个 TCP 连接
- 轮询分配消息到不同连接
- 从所有连接接收数据
- 根据 stream_id 路由数据

**关键方法**:
```rust
pub async fn new(server_ip: &str, server_port: u16, pool_size: usize)
pub async fn send_message(&self, msg: Message)
pub async fn listen_all(&self)
```

### 3. 客户端 (client.rs)

接收本地应用程序连接，通过连接池转发到服务端：

**工作流程**:
1. 监听本地端口
2. 接受应用程序连接
3. 分配唯一 stream_id
4. 发送 NewStream 消息
5. 双向转发数据
6. 连接关闭时发送 CloseStream

### 4. 服务端 (server.rs)

接收 MTCP 连接，转发到后端服务：

**工作流程**:
1. 监听 MTCP 端口
2. 接受客户端连接
3. 解析 MTCP 消息
4. 根据 stream_id 路由到对应后端连接
5. 从后端读取数据返回客户端

### 5. 配置管理 (config.rs)

使用 TOML 格式的配置文件，支持：
- 服务端配置
- 客户端配置
- 参数验证

## 数据流

### 正向数据流 (应用 -> 后端)

```
应用程序
  |
  | TCP 连接
  v
客户端 (127.0.0.1:7000)
  |
  | 1. 分配 stream_id
  | 2. 封装为 MTCP 消息
  v
连接池
  |
  | 轮询选择连接
  | 多个 TCP 连接
  v
服务端 (0.0.0.0:8000)
  |
  | 1. 解析消息
  | 2. 根据 stream_id 路由
  v
后端服务 (127.0.0.1:9000)
```

### 反向数据流 (后端 -> 应用)

```
后端服务
  |
  | 读取数据
  v
服务端
  |
  | 1. 封装为 MTCP 消息
  | 2. 发送到客户端
  v
连接池 (任意连接)
  |
  | 接收并解析
  v
客户端
  |
  | 根据 stream_id 路由
  v
应用程序
```

## 0-RTT 实现

### 传统 TCP 连接建立

```
应用连接 -> TCP 握手 (3次) -> 数据传输
           ~1.5 RTT
```

### MTCP 0-RTT

```
启动时: 预建立连接池
应用连接 -> 立即数据传输
           0 RTT
```

**实现原理**:
1. 客户端启动时建立所有连接
2. 连接保持活跃状态
3. 应用程序连接时直接使用现有连接
4. 无需等待 TCP 握手

## 负载均衡策略

### 轮询 (Round-Robin)

当前实现使用简单的轮询策略：

```rust
let mut next = self.next_conn.lock().await;
let conn_idx = *next;
*next = (*next + 1) % conn_count;
```

**优点**:
- 实现简单
- 分布均匀
- 无状态

**可扩展策略**:
- 最少连接 (Least Connections)
- 加权轮询 (Weighted Round-Robin)
- 响应时间 (Response Time)
- 哈希 (Hash-based)

## 流管理

### Stream ID 分配

```rust
let stream_id = self.next_stream_id.fetch_add(1, Ordering::SeqCst);
```

- 使用原子计数器
- 保证唯一性
- 32位整数 (支持 40 亿+ 并发流)

### Stream 生命周期

```
NewStream -> Data (多次) -> CloseStream
```

### Stream 状态管理

服务端维护 stream_id 到后端连接的映射：

```rust
HashMap<u32, mpsc::Sender<Bytes>>
```

## 并发模型

### Tokio 异步运行时

所有 I/O 操作都是异步的：
- 非阻塞 socket 操作
- 高效的任务调度
- 支持大量并发连接

### 任务分离

每个连接/流都在独立的 tokio 任务中：

```rust
tokio::spawn(async move {
    // 处理连接
});
```

## 错误处理

### 连接级错误

- 连接断开: 自动清理资源
- 超时: 可配置超时参数
- 网络错误: 记录日志并关闭连接

### 流级错误

- 流不存在: 忽略消息
- 后端连接失败: 发送错误给客户端
- 数据损坏: 关闭流

## 性能优化

### 1. 零拷贝

使用 `bytes::Bytes` 实现零拷贝：

```rust
let data = Bytes::copy_from_slice(&buf[..n]);
```

### 2. 缓冲区管理

可配置的缓冲区大小：
- 小缓冲: 低延迟
- 大缓冲: 高吞吐

### 3. 连接复用

预建立的连接池避免：
- TCP 握手延迟
- 慢启动影响
- 连接建立开销

### 4. 并行传输

多个连接并行传输数据：
- 绕过单连接带宽限制
- 提高总吞吐量
- 降低丢包影响

## 安全考虑

### 当前限制

- 无加密: 明文传输
- 无认证: 任何人可连接
- 无完整性校验: 可能被篡改

### 建议增强

1. **TLS 加密**: 在 MTCP 层添加 TLS
2. **认证机制**: 客户端/服务端认证
3. **完整性校验**: 消息 MAC 或签名
4. **速率限制**: 防止 DoS 攻击

## 扩展性

### 水平扩展

服务端可以部署多个实例：
- 使用负载均衡器分发连接
- 每个实例独立处理连接
- 无状态设计便于扩展

### 垂直扩展

增加单实例性能：
- 增大连接池
- 调整缓冲区大小
- 优化系统参数

## 监控指标

### 建议收集的指标

- 活跃连接数
- 每秒消息数
- 数据传输速率
- 错误率
- 延迟分布

### 日志级别

- ERROR: 严重错误
- WARN: 警告信息
- INFO: 重要事件
- DEBUG: 详细调试信息

## 未来改进

1. **动态连接池**: 根据负载自动调整
2. **拥塞控制**: 智能流量控制
3. **QoS**: 流优先级管理
4. **压缩**: 数据压缩减少带宽
5. **加密**: 内置 TLS 支持
6. **监控**: Prometheus 指标导出
7. **管理接口**: HTTP API 管理
8. **配置热更新**: 无需重启更新配置

## 性能基准

### 理论分析

假设：
- 单连接带宽: 10 Mbps
- 连接池大小: 4
- 理论最大: 40 Mbps

实际性能受限于：
- CPU 处理能力
- 内存带宽
- 网络延迟
- 后端服务性能

### 测试建议

使用 `iperf3` 或类似工具测试：

```bash
# 直接连接
iperf3 -c backend_ip -p backend_port

# 通过 MTCP
iperf3 -c 127.0.0.1 -p 7000
```

## 故障恢复

### 连接断开

- 客户端: 尝试重连
- 服务端: 清理资源

### 部分连接失败

- 继续使用剩余连接
- 记录警告日志
- 性能降级但不中断

### 完全失败

- 关闭所有连接
- 通知应用程序
- 等待重启或修复
